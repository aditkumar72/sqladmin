{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLAlchemy Admin for Starlette/FastAPI SQLAdmin is a flexible Admin interface for SQLAlchemy models. Main features include: SQLAlchemy sync/async engines Starlette integration FastAPI integration SQLModel support Modern UI using Tabler Documentation : https://aminalaee.dev/sqladmin Source Code : https://github.com/aminalaee/sqladmin Online Demo : Demo Installation $ pip install sqladmin Quickstart Let's define an example SQLAlchemy model: from sqlalchemy import Column , Integer , String , create_engine from sqlalchemy.ext.declarative import declarative_base Base = declarative_base () engine = create_engine ( \"sqlite:///example.db\" , connect_args = { \"check_same_thread\" : False }, ) class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True ) name = Column ( String ) Base . metadata . create_all ( engine ) # Create tables If you want to use SQLAdmin with FastAPI : from fastapi import FastAPI from sqladmin import Admin , ModelView app = FastAPI () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin ) Or if you want to use SQLAdmin with Starlette : from sqladmin import Admin , ModelView from starlette.applications import Starlette app = Starlette () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin ) Now visiting /admin on your browser you can see the SQLAdmin interface. Related projects and inspirations Flask-Admin Admin interface for Flask supporting different database backends and ORMs. This project has inspired SQLAdmin extensively and most of the features and configurations are implemented the same. FastAPI-Admin Admin interface for FastAPI which works with TortoiseORM . Dashboard Admin interface for ASGI frameworks which works with the orm package.","title":"Introduction"},{"location":"#sqlalchemy-admin-for-starlettefastapi","text":"SQLAdmin is a flexible Admin interface for SQLAlchemy models. Main features include: SQLAlchemy sync/async engines Starlette integration FastAPI integration SQLModel support Modern UI using Tabler Documentation : https://aminalaee.dev/sqladmin Source Code : https://github.com/aminalaee/sqladmin Online Demo : Demo","title":"SQLAlchemy Admin for Starlette/FastAPI"},{"location":"#installation","text":"$ pip install sqladmin","title":"Installation"},{"location":"#quickstart","text":"Let's define an example SQLAlchemy model: from sqlalchemy import Column , Integer , String , create_engine from sqlalchemy.ext.declarative import declarative_base Base = declarative_base () engine = create_engine ( \"sqlite:///example.db\" , connect_args = { \"check_same_thread\" : False }, ) class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True ) name = Column ( String ) Base . metadata . create_all ( engine ) # Create tables If you want to use SQLAdmin with FastAPI : from fastapi import FastAPI from sqladmin import Admin , ModelView app = FastAPI () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin ) Or if you want to use SQLAdmin with Starlette : from sqladmin import Admin , ModelView from starlette.applications import Starlette app = Starlette () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin ) Now visiting /admin on your browser you can see the SQLAdmin interface.","title":"Quickstart"},{"location":"#related-projects-and-inspirations","text":"Flask-Admin Admin interface for Flask supporting different database backends and ORMs. This project has inspired SQLAdmin extensively and most of the features and configurations are implemented the same. FastAPI-Admin Admin interface for FastAPI which works with TortoiseORM . Dashboard Admin interface for ASGI frameworks which works with the orm package.","title":"Related projects and inspirations"},{"location":"authentication/","text":"SQLadmin does not enforce any authentication to your application, but provides an optional AuthenticationBackend you can use. AuthenticationBackend SQLAdmin has a session-based authentication that will allow you to integrate any existing authentication to it. The class AuthenticationBackend has three methods you need to override: authenticate : Will be called for validating each incoming request. login : Will be called only in the login page to validate username/password. logout : Will be called only for the logout, usually clearin the session. from sqladmin import Admin from sqladmin.authentication import AuthenticationBackend from starlette.requests import Request class MyBackend ( AuthenticationBackend ): async def login ( self , request : Request ) -> bool : form = await request . form () username , password = form [ \"username\" ], form [ \"password\" ] # Validate username/password credentials # And update session request . session . update ({ \"token\" : \"...\" }) return True async def logout ( self , request : Request ) -> bool : # Usually you'd want to just clear the session request . session . clear () return True async def authenticate ( self , request : Request ) -> bool : token = request . session . get ( \"token\" ) if not token : return False # Check the token return True authentication_backend = MyBackend ( secret_key = \"...\" ) admin = Admin ( app =... , authentication_backend = authentication_backend \u060c ... ) Note In order to use AuthenticationBackend you need to install the itsdangerous package. Permissions The ModelView and BaseView classes in SQLAdmin implements two special methods you can override. You can use these methods to have control over each Model/View in addition to the AuthenticationBackend. So this is more like checking if the user has access to the specific Model or View. is_visible is_accessible As you might guess the is_visible controls if this Model/View should be displayed in the menu or not. The is_accessible controls if this Model/View should be accessed. Both methods implement the same signature and should return a boolean. Note For Model/View to be displayed in the sidebar both is_visible and is_accessible should return True . So in order to override these methods: from starlette.requests import Request class UserAdmin ( ModelView , model = User ): def is_accessible ( self , request : Request ) -> bool : # Check incoming request # For example request.session if using AuthenticatoinBackend return True def is_visible ( self , request : Request ) -> bool : # Check incoming request # For example request.session if using AuthenticatoinBackend return True Full example from sqladmin import Admin , ModelView from sqladmin.authentication import AuthenticationBackend from sqlalchemy import Column , Integer , String , create_engine from sqlalchemy.ext.declarative import declarative_base from starlette.applications import Starlette from starlette.requests import Request Base = declarative_base () engine = create_engine ( \"sqlite:///example.db\" , connect_args = { \"check_same_thread\" : False }, ) class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True ) name = Column ( String ) Base . metadata . create_all ( engine ) class MyBackend ( AuthenticationBackend ): async def login ( self , request : Request ) -> bool : request . session . update ({ \"token\" : \"...\" }) return True async def logout ( self , request : Request ) -> bool : request . session . clear () return True async def authenticate ( self , request : Request ) -> bool : return \"token\" in request . session app = Starlette () authentication_backend = MyBackend ( secret_key = \"...\" ) admin = Admin ( app = app , engine = engine , authentication_backend = authentication_backend ) class UserAdmin ( ModelView , model = User ): def is_visible ( self , request : Request ) -> bool : return True def is_accessible ( self , request : Request ) -> bool : return True admin . add_view ( UserAdmin )","title":"Authentication"},{"location":"authentication/#authenticationbackend","text":"SQLAdmin has a session-based authentication that will allow you to integrate any existing authentication to it. The class AuthenticationBackend has three methods you need to override: authenticate : Will be called for validating each incoming request. login : Will be called only in the login page to validate username/password. logout : Will be called only for the logout, usually clearin the session. from sqladmin import Admin from sqladmin.authentication import AuthenticationBackend from starlette.requests import Request class MyBackend ( AuthenticationBackend ): async def login ( self , request : Request ) -> bool : form = await request . form () username , password = form [ \"username\" ], form [ \"password\" ] # Validate username/password credentials # And update session request . session . update ({ \"token\" : \"...\" }) return True async def logout ( self , request : Request ) -> bool : # Usually you'd want to just clear the session request . session . clear () return True async def authenticate ( self , request : Request ) -> bool : token = request . session . get ( \"token\" ) if not token : return False # Check the token return True authentication_backend = MyBackend ( secret_key = \"...\" ) admin = Admin ( app =... , authentication_backend = authentication_backend \u060c ... ) Note In order to use AuthenticationBackend you need to install the itsdangerous package.","title":"AuthenticationBackend"},{"location":"authentication/#permissions","text":"The ModelView and BaseView classes in SQLAdmin implements two special methods you can override. You can use these methods to have control over each Model/View in addition to the AuthenticationBackend. So this is more like checking if the user has access to the specific Model or View. is_visible is_accessible As you might guess the is_visible controls if this Model/View should be displayed in the menu or not. The is_accessible controls if this Model/View should be accessed. Both methods implement the same signature and should return a boolean. Note For Model/View to be displayed in the sidebar both is_visible and is_accessible should return True . So in order to override these methods: from starlette.requests import Request class UserAdmin ( ModelView , model = User ): def is_accessible ( self , request : Request ) -> bool : # Check incoming request # For example request.session if using AuthenticatoinBackend return True def is_visible ( self , request : Request ) -> bool : # Check incoming request # For example request.session if using AuthenticatoinBackend return True","title":"Permissions"},{"location":"authentication/#full-example","text":"from sqladmin import Admin , ModelView from sqladmin.authentication import AuthenticationBackend from sqlalchemy import Column , Integer , String , create_engine from sqlalchemy.ext.declarative import declarative_base from starlette.applications import Starlette from starlette.requests import Request Base = declarative_base () engine = create_engine ( \"sqlite:///example.db\" , connect_args = { \"check_same_thread\" : False }, ) class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True ) name = Column ( String ) Base . metadata . create_all ( engine ) class MyBackend ( AuthenticationBackend ): async def login ( self , request : Request ) -> bool : request . session . update ({ \"token\" : \"...\" }) return True async def logout ( self , request : Request ) -> bool : request . session . clear () return True async def authenticate ( self , request : Request ) -> bool : return \"token\" in request . session app = Starlette () authentication_backend = MyBackend ( secret_key = \"...\" ) admin = Admin ( app = app , engine = engine , authentication_backend = authentication_backend ) class UserAdmin ( ModelView , model = User ): def is_visible ( self , request : Request ) -> bool : return True def is_accessible ( self , request : Request ) -> bool : return True admin . add_view ( UserAdmin )","title":"Full example"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Version 0.8.0 - 2022-11-22 Added Add save_as option by @aminalaee in #377 Add save_as_continue option by @aminalaee in #379 Add extra Save buttons for Create/Edit page by @aminalaee in #373 Display errors in alert for create/edit page by @aminalaee in #382 Fixed Fix _url_for methods ignoring root_path by @aminalaee in #371 Fix export to use list_query option by @villqrd in #381 Version 0.7.0 - 2022-11-03 Added Add on_model_change and after_model_change methods in #342 Add on_model_delete and after_model_delete methods in #343 Fixed Fix search by uuid column in #366 Update tests after starlette upgrade in #344 Remove hard-coded related model limit in #354 Improve items list UI in #349 Make navbar work on small screens in #362 Internal Add mypy check with config no_implicit_optional in #360 Support test-suite py311 in #365 Add py.typed for the package to ship its typing information in #346 Version 0.6.1 - 2022-09-25 Fixed Fix Boolean field for both nullable and non-nullable cases in #336 Fix Flatpickr not respecting readonly inputs in #336 Disable batch delete when can_delete permission is not provided in #335 Version 0.6.0 - 2022-09-19 Added Add bulk delete action in #317 Fixed Handle null values when column is nullable in #323 Switch Boolean field to select field in #321 Internal Fix form_ajax_refs example in documentation in #311 Remove watch in mkdocstrings mkdocs's config in #306 Version 0.5.0 - 2022-09-06 Added Add remote_ajax_refs in #292 Internal Avoid select query with ajax_form_refs in #300 Add docs for form_ajax_refs in #302 Version 0.4.0 - 2022-08-31 Added Add Date and DateTime pickers using Fatpickr in #288 Add Time picker using Flatpickr in #294 Internal Remove MomentJS in #289 Remove Select2 widgets in #293 Version 0.3.0 - 2022-08-26 Added Add AuthenticationBackend in #277 Update Authentication docs in #278 Version 0.2.1 - 2022-08-04 Fixed Fix middlewares and ENGINE_TYPE types in #266 Fix middlewares not being applied in #267 and #271 Version 0.2.0 - 2022-08-01 Added Add list_query , count_query and search_query options in #243 Add BaseView for custom pages in #244 Add expose for BaseView in #251 Rename ModelAdmin to ModelView in #249 Version 0.1.12 - 2022-07-13 Added Add time field converter in #214 Add Edit button for \"Details\" page in #222 Add column_type_formatters in #239 Fixed Fix lazy subuqery in list query in #212 Fix missing browser tab title in #229 Remove sourceMappingURL in JS files in #231 Version 0.1.11 - 2022-06-23 Added Add form_include_pk option in #207 Fixed Fix handling of iterable fields in #204 Fix nullable Enum form in #205 Version 0.1.10 - 2022-06-21 Added Add support for one-to-one relationship in #186 Add support for UUIDType from sqlalchemy_utils in #183 Add sqlalchemy_utils URL, Currency and Timezone in #185 Add form_widget_args in #188 Add column_default_sort in #191 Fixed Fix link relationship to details page when null in #174 docs: fix typos in #161 Allow QuerySelectField override object_list with form_args in #171 Fix form fields order when specifying columns in #184 Fix ModelConverter when impl is not callable in #186 Version 0.1.9 - 2022-05-27 Added Add column_formatters in #140 Add column_formatters_detail in #141 Handling for sqlalchemy_utils EmailType and IPAddressType in #150 Link relationships to detail page in #153 Fixed Function signature typing, and renames in #116 Fix SQLModel UUID type in #158 Version 0.1.8 - 2022-04-19 Added Add csv export support in #101 Expose Starlette middlewares and debug to the Admin in #114 Fixed Fix Export unlimited rows in #107 Add form and export options docs in #110 fix docstring issues by adding an explicit handler in #106 Fix get_model_attr with column labels in #128 Delay call to self.get_converter to use form_overrides in #129 Version 0.1.7 - 2022-03-22 Added Add SQLModel support in #94 Add form-specific functionality to ModelAdmin in #97 Add UUID field converter in #82 Add PostgreSQL INET and MACADDR converters in #83 Fixed Fix Boolean field checkbox UI in #88 Fix PostgreSQL UUID PrimaryKey in #92 Fix Source Code Link in #95 Version 0.1.6 - 2022-03-09 Added FontAwesome6 icons in #78 Add column_sortable_list in #65 Add JSON column converters in #74 Fixed Fix URL search regex in #67 Fix Enum in Edit page in #71 Version 0.1.5 - 2022-02-24 Added Authentication in #37 Add Edit view page in #60 Add column_searchable_list in #61 Internal Cleanup DB queries in #51 Version 0.1.4 - 2022-02-16 Added Allow templates to be configured in #52 Add page size option links in #34 Fixed Improve pagination in #36 Internal Instantiate ModelAdmin internally to avoid class methods in #31 Version 0.1.3 - 2022-01-24 Added Add title and logo options in #20 Adding order_by to list pagination query in #25 Allow Relationship properties in list and detail views in #22","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#version-080-2022-11-22","text":"","title":"Version 0.8.0 - 2022-11-22"},{"location":"changelog/#added","text":"Add save_as option by @aminalaee in #377 Add save_as_continue option by @aminalaee in #379 Add extra Save buttons for Create/Edit page by @aminalaee in #373 Display errors in alert for create/edit page by @aminalaee in #382","title":"Added"},{"location":"changelog/#fixed","text":"Fix _url_for methods ignoring root_path by @aminalaee in #371 Fix export to use list_query option by @villqrd in #381","title":"Fixed"},{"location":"changelog/#version-070-2022-11-03","text":"","title":"Version 0.7.0 - 2022-11-03"},{"location":"changelog/#added_1","text":"Add on_model_change and after_model_change methods in #342 Add on_model_delete and after_model_delete methods in #343","title":"Added"},{"location":"changelog/#fixed_1","text":"Fix search by uuid column in #366 Update tests after starlette upgrade in #344 Remove hard-coded related model limit in #354 Improve items list UI in #349 Make navbar work on small screens in #362","title":"Fixed"},{"location":"changelog/#internal","text":"Add mypy check with config no_implicit_optional in #360 Support test-suite py311 in #365 Add py.typed for the package to ship its typing information in #346","title":"Internal"},{"location":"changelog/#version-061-2022-09-25","text":"","title":"Version 0.6.1 - 2022-09-25"},{"location":"changelog/#fixed_2","text":"Fix Boolean field for both nullable and non-nullable cases in #336 Fix Flatpickr not respecting readonly inputs in #336 Disable batch delete when can_delete permission is not provided in #335","title":"Fixed"},{"location":"changelog/#version-060-2022-09-19","text":"","title":"Version 0.6.0 - 2022-09-19"},{"location":"changelog/#added_2","text":"Add bulk delete action in #317","title":"Added"},{"location":"changelog/#fixed_3","text":"Handle null values when column is nullable in #323 Switch Boolean field to select field in #321","title":"Fixed"},{"location":"changelog/#internal_1","text":"Fix form_ajax_refs example in documentation in #311 Remove watch in mkdocstrings mkdocs's config in #306","title":"Internal"},{"location":"changelog/#version-050-2022-09-06","text":"","title":"Version 0.5.0 - 2022-09-06"},{"location":"changelog/#added_3","text":"Add remote_ajax_refs in #292","title":"Added"},{"location":"changelog/#internal_2","text":"Avoid select query with ajax_form_refs in #300 Add docs for form_ajax_refs in #302","title":"Internal"},{"location":"changelog/#version-040-2022-08-31","text":"","title":"Version 0.4.0 - 2022-08-31"},{"location":"changelog/#added_4","text":"Add Date and DateTime pickers using Fatpickr in #288 Add Time picker using Flatpickr in #294","title":"Added"},{"location":"changelog/#internal_3","text":"Remove MomentJS in #289 Remove Select2 widgets in #293","title":"Internal"},{"location":"changelog/#version-030-2022-08-26","text":"","title":"Version 0.3.0 - 2022-08-26"},{"location":"changelog/#added_5","text":"Add AuthenticationBackend in #277 Update Authentication docs in #278","title":"Added"},{"location":"changelog/#version-021-2022-08-04","text":"","title":"Version 0.2.1 - 2022-08-04"},{"location":"changelog/#fixed_4","text":"Fix middlewares and ENGINE_TYPE types in #266 Fix middlewares not being applied in #267 and #271","title":"Fixed"},{"location":"changelog/#version-020-2022-08-01","text":"","title":"Version 0.2.0 - 2022-08-01"},{"location":"changelog/#added_6","text":"Add list_query , count_query and search_query options in #243 Add BaseView for custom pages in #244 Add expose for BaseView in #251 Rename ModelAdmin to ModelView in #249","title":"Added"},{"location":"changelog/#version-0112-2022-07-13","text":"","title":"Version 0.1.12 - 2022-07-13"},{"location":"changelog/#added_7","text":"Add time field converter in #214 Add Edit button for \"Details\" page in #222 Add column_type_formatters in #239","title":"Added"},{"location":"changelog/#fixed_5","text":"Fix lazy subuqery in list query in #212 Fix missing browser tab title in #229 Remove sourceMappingURL in JS files in #231","title":"Fixed"},{"location":"changelog/#version-0111-2022-06-23","text":"","title":"Version 0.1.11 - 2022-06-23"},{"location":"changelog/#added_8","text":"Add form_include_pk option in #207","title":"Added"},{"location":"changelog/#fixed_6","text":"Fix handling of iterable fields in #204 Fix nullable Enum form in #205","title":"Fixed"},{"location":"changelog/#version-0110-2022-06-21","text":"","title":"Version 0.1.10 - 2022-06-21"},{"location":"changelog/#added_9","text":"Add support for one-to-one relationship in #186 Add support for UUIDType from sqlalchemy_utils in #183 Add sqlalchemy_utils URL, Currency and Timezone in #185 Add form_widget_args in #188 Add column_default_sort in #191","title":"Added"},{"location":"changelog/#fixed_7","text":"Fix link relationship to details page when null in #174 docs: fix typos in #161 Allow QuerySelectField override object_list with form_args in #171 Fix form fields order when specifying columns in #184 Fix ModelConverter when impl is not callable in #186","title":"Fixed"},{"location":"changelog/#version-019-2022-05-27","text":"","title":"Version 0.1.9 - 2022-05-27"},{"location":"changelog/#added_10","text":"Add column_formatters in #140 Add column_formatters_detail in #141 Handling for sqlalchemy_utils EmailType and IPAddressType in #150 Link relationships to detail page in #153","title":"Added"},{"location":"changelog/#fixed_8","text":"Function signature typing, and renames in #116 Fix SQLModel UUID type in #158","title":"Fixed"},{"location":"changelog/#version-018-2022-04-19","text":"","title":"Version 0.1.8 - 2022-04-19"},{"location":"changelog/#added_11","text":"Add csv export support in #101 Expose Starlette middlewares and debug to the Admin in #114","title":"Added"},{"location":"changelog/#fixed_9","text":"Fix Export unlimited rows in #107 Add form and export options docs in #110 fix docstring issues by adding an explicit handler in #106 Fix get_model_attr with column labels in #128 Delay call to self.get_converter to use form_overrides in #129","title":"Fixed"},{"location":"changelog/#version-017-2022-03-22","text":"","title":"Version 0.1.7 - 2022-03-22"},{"location":"changelog/#added_12","text":"Add SQLModel support in #94 Add form-specific functionality to ModelAdmin in #97 Add UUID field converter in #82 Add PostgreSQL INET and MACADDR converters in #83","title":"Added"},{"location":"changelog/#fixed_10","text":"Fix Boolean field checkbox UI in #88 Fix PostgreSQL UUID PrimaryKey in #92 Fix Source Code Link in #95","title":"Fixed"},{"location":"changelog/#version-016-2022-03-09","text":"","title":"Version 0.1.6 - 2022-03-09"},{"location":"changelog/#added_13","text":"FontAwesome6 icons in #78 Add column_sortable_list in #65 Add JSON column converters in #74","title":"Added"},{"location":"changelog/#fixed_11","text":"Fix URL search regex in #67 Fix Enum in Edit page in #71","title":"Fixed"},{"location":"changelog/#version-015-2022-02-24","text":"","title":"Version 0.1.5 - 2022-02-24"},{"location":"changelog/#added_14","text":"Authentication in #37 Add Edit view page in #60 Add column_searchable_list in #61","title":"Added"},{"location":"changelog/#internal_4","text":"Cleanup DB queries in #51","title":"Internal"},{"location":"changelog/#version-014-2022-02-16","text":"","title":"Version 0.1.4 - 2022-02-16"},{"location":"changelog/#added_15","text":"Allow templates to be configured in #52 Add page size option links in #34","title":"Added"},{"location":"changelog/#fixed_12","text":"Improve pagination in #36","title":"Fixed"},{"location":"changelog/#internal_5","text":"Instantiate ModelAdmin internally to avoid class methods in #31","title":"Internal"},{"location":"changelog/#version-013-2022-01-24","text":"","title":"Version 0.1.3 - 2022-01-24"},{"location":"changelog/#added_16","text":"Add title and logo options in #20 Adding order_by to list pagination query in #25 Allow Relationship properties in list and detail views in #22","title":"Added"},{"location":"configurations/","text":"SQLAdmin configuration options are heavily inspired by the Flask-Admin project. This page will give you a basic introduction and for all the details you can visit API Reference . Let's say you've defined your SQLAlchemy models like this: from sqlalchemy import Column , Integer , String , create_engine from sqlalchemy.ext.declarative import declarative_base Base = declarative_base () engine = create_engine ( \"sqlite:///example.db\" , connect_args = { \"check_same_thread\" : False }, ) class User ( Base ): __tablename__ = \"users\" id = Column ( Integer , primary_key = True ) name = Column ( String ) email = Column ( String ) Base . metadata . create_all ( engine ) # Create tables If you want to integrate SQLAdmin into FastAPI application: from fastapi import FastAPI from sqladmin import Admin , ModelView app = FastAPI () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin ) As you can see the UserAdmin class inherits from ModelView and accepts some configurations. Permissions You can configure a few general permissions for this model. The following options are available: can_create : If the model can create new instances via SQLAdmin. Default value is True . can_edit : If the model instances can be edited via SQLAdmin. Default value is True . can_delete : If the model instances can be deleted via SQLAdmin. Default value is True . can_view_details : If the model instance details can be viewed via SQLAdmin. Default value is True . can_export : If the model data can be exported in the list page. Default value is True . Example class UserAdmin ( ModelView , model = User ): can_create = True can_edit = True can_delete = False can_view_details = True Metadata The metadata for the model. The options are: name : Display name for this model. Default value is the class name. name_plural : Display plural name for this model. Default value is class name + s . icon : Icon to be displayed for this model in the admin. Only FontAwesome names are supported. Example class UserAdmin ( ModelView , model = User ): name = \"User\" name_plural = \"Users\" icon = \"fa-solid fa-user\" List page These options allow configurations in the list page, in the case of this example where you can view list of User records. The options available are: column_list : List of columns or column names to be displayed in the list page. column_exclude_list : List of columns or column names to be excluded in the list page. column_formatters : Dictionary of column formatters in the list page. column_searchable_list : List of columns or column names to be searchable in the list page. column_sortable_list : List of columns or column names to be sortable in the list page. column_default_sort : Default sorting if no sorting is applied, tuple of (column, is_descending) or list of the tuple for multiple columns. list_query : A SQLAlchemy select expression to use for model list page. count_query : A SQLAlchemy select expression to use for model count. search_query : A method with the signature of (stmt, term) -> stmt which can customize the search query. Example class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] # column_list = [\"id\", \"name\"] class UserAdmin ( ModelView , model = User ): column_exclude_list = [ User . id ] class UserAdmin ( ModelView , model = User ): column_searchable_list = [ User . name ] column_sortable_list = [ User . id ] column_formatters = { User . name : lambda m , a : m . name [: 10 ]} column_default_sort = [( User . email , True ), ( User . name , False )] Details page These options allow configurations in the details page, in the case of this example where you can view details of a single User. The options available are: column_details_list : List of columns or column names to be displayed in the details page. column_details_exclude_list : List of columns or column names to be excluded in the details page. column_formatters_detail : Dictionary of column formatters in the details page. Example class UserAdmin ( ModelView , model = User ): column_details_list = [ User . id , User . name ] class UserAdmin ( ModelView , model = User ): column_details_exclude_list = [ User . id ] class UserAdmin ( ModelView , model = User ): column_formatters_detail = { User . name : lambda m , a : m . name [: 10 ]} Pagination options The pagination options in the list page can be configured. The available options include: page_size : Default page size in pagination. Default is 10 . page_size_options : Pagination selector options. Default is [10, 25, 50, 100] . Example class UserAdmin ( ModelView , model = User ): page_size = 50 page_size_options = [ 25 , 50 , 100 , 200 ] General options There are a few options which apply to both List and Detail pages. They include: column_labels : A mapping of column labels, used to map column names to new names in all places. column_type_formatters : A mapping of type keys and callable values to format in all places. For example you can add custom date formatter to be used in both list and detail pages. save_as : A boolean to enable \"save as new\" option when editing an object. save_as_continue : A boolean to control the redirect URL if save_as is enabled. Example class UserAdmin ( ModelView , model = User ): def date_format ( value ): return value . strftime ( \" %d .%m.%Y\" ) column_labels = { User . mail : \"Email\" } column_type_formatters = dict ( ModelView . column_type_formatters , date = date_format ) save_as = True Form options SQLAdmin allows customizing how forms work with your models. The forms are based on WTForms package and include the following options: form : Default form to be used for creating or editing the model. Default value is None and form is created dynamically. form_base_class : Default base class for creating forms. Default value is wtforms.Form . form_args : Dictionary of form field arguments supported by WTForms. form_widget_args : Dictionary of form widget rendering arguments supported by WTForms. form_columns : List of model columns to be included in the form. Default is all model columns. form_excluded_columns : List of model columns to be excluded from the form. form_overrides : Dictionary of form fields to override when creating the form. form_include_pk : Control if primary key column should be included in create/edit forms. Default is False . form_ajax_refs : Use Ajax with Select2 for loading relationship models async. This is use ful when the related model has a lot of records. Example class UserAdmin ( ModelView , model = User ): form_columns = [ User . name ] form_args = dict ( name = dict ( label = \"Full name\" )) form_widget_args = dict ( email = dict ( readonly = True )) form_overrides = dict ( email = wtforms . EmailField ) form_include_pk = True form_ajax_refs = { \"address\" : { \"fields\" : ( \"zip_code\" , \"street\" ), \"order_by\" : ( \"id\" ,), } } Export options SQLAdmin supports exporting data in the list page. Currently only CSV export is supported. The export options can be set per model and includes the following options: can_export : If the model can be exported. Default value is True . column_export_list : List of columns to include in the export data. Default is all model columns. column_export_exclude_list : List of columns to exclude in the export data. export_max_rows : Maximum number of rows to be exported. Default value is 0 which means unlimited. export_types : List of export types to be enabled. Default value is [\"csv\"] . Templates The template files are built using Jinja2 and can be completely overridden in the configurations. The pages available are: list_template : Template to use for models list page. Default is list.html . create_template : Template to use for model creation page. Default is create.html . details_template : Template to use for model details page. Default is details.html . edit_template : Template to use for model edit page. Default is edit.html . Example class UserAdmin ( ModelView , model = User ): list_template = \"custom_list.html\" For more information about working with template see Working with Templates . Custom Views To add custom views to the Admin interface, you can use the BaseView included in SQLAdmin. For example: Example from sqladmin import BaseView , expose class CustomView ( BaseView ): name = \"Custom Page\" icon = \"fa-chart-line\" @expose ( \"/custom\" , methods = [ \"GET\" ]) def custom_page ( self , request ): return self . templates . TemplateResponse ( \"custom.html\" , context = { \"request\" : request }, ) admin . add_view ( CustomView ) This will assume a templates directory exists in your project. You can modify this when you create an Admin instance: from sqladmin import Admin admin = Admin ( templates_dir = \"my_templates\" , ... ) Events There might be some cases which you want to do some actions before or after a model was created, updated or deleted. There are four methods you can override to achieve this: on_model_change : Called before a model was created or updated. after_model_change : Called after a model was created or updated. on_model_delete : Called before a model was deleted. after_model_delete : Called after a model was deleted. By default these methods do nothing. Example class UserAdmin ( ModelView , model = User ): async def on_model_change ( self , data , model , is_created ): # Perform some other action ... async def on_model_delete ( self , model ): # Perform some other action ...","title":"Configurations"},{"location":"configurations/#permissions","text":"You can configure a few general permissions for this model. The following options are available: can_create : If the model can create new instances via SQLAdmin. Default value is True . can_edit : If the model instances can be edited via SQLAdmin. Default value is True . can_delete : If the model instances can be deleted via SQLAdmin. Default value is True . can_view_details : If the model instance details can be viewed via SQLAdmin. Default value is True . can_export : If the model data can be exported in the list page. Default value is True . Example class UserAdmin ( ModelView , model = User ): can_create = True can_edit = True can_delete = False can_view_details = True","title":"Permissions"},{"location":"configurations/#metadata","text":"The metadata for the model. The options are: name : Display name for this model. Default value is the class name. name_plural : Display plural name for this model. Default value is class name + s . icon : Icon to be displayed for this model in the admin. Only FontAwesome names are supported. Example class UserAdmin ( ModelView , model = User ): name = \"User\" name_plural = \"Users\" icon = \"fa-solid fa-user\"","title":"Metadata"},{"location":"configurations/#list-page","text":"These options allow configurations in the list page, in the case of this example where you can view list of User records. The options available are: column_list : List of columns or column names to be displayed in the list page. column_exclude_list : List of columns or column names to be excluded in the list page. column_formatters : Dictionary of column formatters in the list page. column_searchable_list : List of columns or column names to be searchable in the list page. column_sortable_list : List of columns or column names to be sortable in the list page. column_default_sort : Default sorting if no sorting is applied, tuple of (column, is_descending) or list of the tuple for multiple columns. list_query : A SQLAlchemy select expression to use for model list page. count_query : A SQLAlchemy select expression to use for model count. search_query : A method with the signature of (stmt, term) -> stmt which can customize the search query. Example class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] # column_list = [\"id\", \"name\"] class UserAdmin ( ModelView , model = User ): column_exclude_list = [ User . id ] class UserAdmin ( ModelView , model = User ): column_searchable_list = [ User . name ] column_sortable_list = [ User . id ] column_formatters = { User . name : lambda m , a : m . name [: 10 ]} column_default_sort = [( User . email , True ), ( User . name , False )]","title":"List page"},{"location":"configurations/#details-page","text":"These options allow configurations in the details page, in the case of this example where you can view details of a single User. The options available are: column_details_list : List of columns or column names to be displayed in the details page. column_details_exclude_list : List of columns or column names to be excluded in the details page. column_formatters_detail : Dictionary of column formatters in the details page. Example class UserAdmin ( ModelView , model = User ): column_details_list = [ User . id , User . name ] class UserAdmin ( ModelView , model = User ): column_details_exclude_list = [ User . id ] class UserAdmin ( ModelView , model = User ): column_formatters_detail = { User . name : lambda m , a : m . name [: 10 ]}","title":"Details page"},{"location":"configurations/#pagination-options","text":"The pagination options in the list page can be configured. The available options include: page_size : Default page size in pagination. Default is 10 . page_size_options : Pagination selector options. Default is [10, 25, 50, 100] . Example class UserAdmin ( ModelView , model = User ): page_size = 50 page_size_options = [ 25 , 50 , 100 , 200 ]","title":"Pagination options"},{"location":"configurations/#general-options","text":"There are a few options which apply to both List and Detail pages. They include: column_labels : A mapping of column labels, used to map column names to new names in all places. column_type_formatters : A mapping of type keys and callable values to format in all places. For example you can add custom date formatter to be used in both list and detail pages. save_as : A boolean to enable \"save as new\" option when editing an object. save_as_continue : A boolean to control the redirect URL if save_as is enabled. Example class UserAdmin ( ModelView , model = User ): def date_format ( value ): return value . strftime ( \" %d .%m.%Y\" ) column_labels = { User . mail : \"Email\" } column_type_formatters = dict ( ModelView . column_type_formatters , date = date_format ) save_as = True","title":"General options"},{"location":"configurations/#form-options","text":"SQLAdmin allows customizing how forms work with your models. The forms are based on WTForms package and include the following options: form : Default form to be used for creating or editing the model. Default value is None and form is created dynamically. form_base_class : Default base class for creating forms. Default value is wtforms.Form . form_args : Dictionary of form field arguments supported by WTForms. form_widget_args : Dictionary of form widget rendering arguments supported by WTForms. form_columns : List of model columns to be included in the form. Default is all model columns. form_excluded_columns : List of model columns to be excluded from the form. form_overrides : Dictionary of form fields to override when creating the form. form_include_pk : Control if primary key column should be included in create/edit forms. Default is False . form_ajax_refs : Use Ajax with Select2 for loading relationship models async. This is use ful when the related model has a lot of records. Example class UserAdmin ( ModelView , model = User ): form_columns = [ User . name ] form_args = dict ( name = dict ( label = \"Full name\" )) form_widget_args = dict ( email = dict ( readonly = True )) form_overrides = dict ( email = wtforms . EmailField ) form_include_pk = True form_ajax_refs = { \"address\" : { \"fields\" : ( \"zip_code\" , \"street\" ), \"order_by\" : ( \"id\" ,), } }","title":"Form options"},{"location":"configurations/#export-options","text":"SQLAdmin supports exporting data in the list page. Currently only CSV export is supported. The export options can be set per model and includes the following options: can_export : If the model can be exported. Default value is True . column_export_list : List of columns to include in the export data. Default is all model columns. column_export_exclude_list : List of columns to exclude in the export data. export_max_rows : Maximum number of rows to be exported. Default value is 0 which means unlimited. export_types : List of export types to be enabled. Default value is [\"csv\"] .","title":"Export options"},{"location":"configurations/#templates","text":"The template files are built using Jinja2 and can be completely overridden in the configurations. The pages available are: list_template : Template to use for models list page. Default is list.html . create_template : Template to use for model creation page. Default is create.html . details_template : Template to use for model details page. Default is details.html . edit_template : Template to use for model edit page. Default is edit.html . Example class UserAdmin ( ModelView , model = User ): list_template = \"custom_list.html\" For more information about working with template see Working with Templates .","title":"Templates"},{"location":"configurations/#custom-views","text":"To add custom views to the Admin interface, you can use the BaseView included in SQLAdmin. For example: Example from sqladmin import BaseView , expose class CustomView ( BaseView ): name = \"Custom Page\" icon = \"fa-chart-line\" @expose ( \"/custom\" , methods = [ \"GET\" ]) def custom_page ( self , request ): return self . templates . TemplateResponse ( \"custom.html\" , context = { \"request\" : request }, ) admin . add_view ( CustomView ) This will assume a templates directory exists in your project. You can modify this when you create an Admin instance: from sqladmin import Admin admin = Admin ( templates_dir = \"my_templates\" , ... )","title":"Custom Views"},{"location":"configurations/#events","text":"There might be some cases which you want to do some actions before or after a model was created, updated or deleted. There are four methods you can override to achieve this: on_model_change : Called before a model was created or updated. after_model_change : Called after a model was created or updated. on_model_delete : Called before a model was deleted. after_model_delete : Called after a model was deleted. By default these methods do nothing. Example class UserAdmin ( ModelView , model = User ): async def on_model_change ( self , data , model , is_created ): # Perform some other action ... async def on_model_delete ( self , model ): # Perform some other action ...","title":"Events"},{"location":"faq/","text":"How to deploy to production with HTTPS enabled? This is not really related to SQLAdmin but in case you are deploying in a production environment you will enable HTTPS with a reverse proxy like Nginx or Kubernetes Ingress. If you are deploying the application with Uvicorn you can follow the docs for running behind nginx and all you probably need is to start Uvicorn with --forwarded-allow-ips='*' and --proxy-headers to pass the correct HTTP headers.","title":"Frequently Asked Questions"},{"location":"faq/#how-to-deploy-to-production-with-https-enabled","text":"This is not really related to SQLAdmin but in case you are deploying in a production environment you will enable HTTPS with a reverse proxy like Nginx or Kubernetes Ingress. If you are deploying the application with Uvicorn you can follow the docs for running behind nginx and all you probably need is to start Uvicorn with --forwarded-allow-ips='*' and --proxy-headers to pass the correct HTTP headers.","title":"How to deploy to production with HTTPS enabled?"},{"location":"working_with_templates/","text":"There are different approaches when it comes to working with templates in SQLAdmin. You can simply replace a template file and implement it yourself, or you could customize parts of the template without implementing the whole page. Replacing templates You can create a directory called templates in your project and create relevant template files in it. If you name your files the same way SQLAdmin does, for example list.html or details.html then you don't have to do anything else. They will be picked up by SQLAdmin automatically. But if you name the files something else, then you need to specify the name in your ModelView classes. Example class UserAdmin ( ModelView , model = User ): details_template = \"details.html\" list_template = \"custom_list.html\" Customizing templates","title":"Working with Templates"},{"location":"working_with_templates/#replacing-templates","text":"You can create a directory called templates in your project and create relevant template files in it. If you name your files the same way SQLAdmin does, for example list.html or details.html then you don't have to do anything else. They will be picked up by SQLAdmin automatically. But if you name the files something else, then you need to specify the name in your ModelView classes. Example class UserAdmin ( ModelView , model = User ): details_template = \"details.html\" list_template = \"custom_list.html\"","title":"Replacing templates"},{"location":"working_with_templates/#customizing-templates","text":"","title":"Customizing templates"},{"location":"api_reference/application/","text":"sqladmin.application.Admin ( BaseAdminView ) Main entrypoint to admin interface. Usage from fastapi import FastAPI from sqladmin import Admin , ModelView from mymodels import User # SQLAlchemy model app = FastAPI () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin ) __init__ ( self , app , engine , base_url = '/admin' , title = 'Admin' , logo_url = None , middlewares = None , debug = False , templates_dir = 'templates' , authentication_backend = None ) special Parameters: Name Type Description Default app Starlette Starlette or FastAPI application. required engine Union[sqlalchemy.engine.base.Engine, sqlalchemy.ext.asyncio.engine.AsyncEngine] SQLAlchemy engine instance. required base_url str Base URL for Admin interface. '/admin' title str Admin title. 'Admin' logo_url Optional[str] URL of logo to be displayed instead of title. None sqladmin.application.BaseAdmin Base class for implementing Admin interface. Danger This class should almost never be used directly. views : List [ Union [ sqladmin . models . BaseView , sqladmin . models . ModelView ]] property readonly Get list of ModelView and BaseView instances lazily. Returns: Type Description List[Union[sqladmin.models.BaseView, sqladmin.models.ModelView]] List of ModelView and BaseView instances added to Admin. add_base_view ( self , view ) Add BaseView to the Admin. Usage from sqladmin import BaseView , expose class CustomAdmin ( BaseView ): name = \"Custom Page\" icon = \"fa-solid fa-chart-line\" @expose ( \"/custom\" , methods = [ \"GET\" ]) def test_page ( self , request : Request ): return self . templates . TemplateResponse ( \"custom.html\" , context = { \"request\" : request }, ) admin . add_base_view ( CustomAdmin ) add_model_view ( self , view ) Add ModelView to the Admin. Usage from sqladmin import Admin , ModelView class UserAdmin ( ModelView , model = User ): pass admin . add_model_view ( UserAdmin ) add_view ( self , view ) Add ModelView or BaseView classes to Admin. This is a shortcut that will handle both add_model_view and add_base_view .","title":"Application"},{"location":"api_reference/application/#sqladmin.application.Admin","text":"Main entrypoint to admin interface. Usage from fastapi import FastAPI from sqladmin import Admin , ModelView from mymodels import User # SQLAlchemy model app = FastAPI () admin = Admin ( app , engine ) class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] admin . add_view ( UserAdmin )","title":"Admin"},{"location":"api_reference/application/#sqladmin.application.Admin.__init__","text":"Parameters: Name Type Description Default app Starlette Starlette or FastAPI application. required engine Union[sqlalchemy.engine.base.Engine, sqlalchemy.ext.asyncio.engine.AsyncEngine] SQLAlchemy engine instance. required base_url str Base URL for Admin interface. '/admin' title str Admin title. 'Admin' logo_url Optional[str] URL of logo to be displayed instead of title. None","title":"__init__()"},{"location":"api_reference/application/#sqladmin.application.BaseAdmin","text":"Base class for implementing Admin interface. Danger This class should almost never be used directly.","title":"BaseAdmin"},{"location":"api_reference/application/#sqladmin.application.BaseAdmin.views","text":"Get list of ModelView and BaseView instances lazily. Returns: Type Description List[Union[sqladmin.models.BaseView, sqladmin.models.ModelView]] List of ModelView and BaseView instances added to Admin.","title":"views"},{"location":"api_reference/application/#sqladmin.application.BaseAdmin.add_base_view","text":"Add BaseView to the Admin. Usage from sqladmin import BaseView , expose class CustomAdmin ( BaseView ): name = \"Custom Page\" icon = \"fa-solid fa-chart-line\" @expose ( \"/custom\" , methods = [ \"GET\" ]) def test_page ( self , request : Request ): return self . templates . TemplateResponse ( \"custom.html\" , context = { \"request\" : request }, ) admin . add_base_view ( CustomAdmin )","title":"add_base_view()"},{"location":"api_reference/application/#sqladmin.application.BaseAdmin.add_model_view","text":"Add ModelView to the Admin. Usage from sqladmin import Admin , ModelView class UserAdmin ( ModelView , model = User ): pass admin . add_model_view ( UserAdmin )","title":"add_model_view()"},{"location":"api_reference/application/#sqladmin.application.BaseAdmin.add_view","text":"Add ModelView or BaseView classes to Admin. This is a shortcut that will handle both add_model_view and add_base_view .","title":"add_view()"},{"location":"api_reference/authentication/","text":"sqladmin.authentication.AuthenticationBackend Base class for implementing the Authentication into SQLAdmin. You need to inherit this class and override the methods: login , logout and authenticate . authenticate ( self , request ) async Implement authenticate logic here. This method will be called for each incoming request to validate the authentication. login ( self , request ) async Implement login logic here. You can access the login form data await request.form() andvalidate the credentials. logout ( self , request ) async Implement logout logic here. This will usually clear the session with request.session.clear() .","title":"Authentication"},{"location":"api_reference/authentication/#sqladmin.authentication.AuthenticationBackend","text":"Base class for implementing the Authentication into SQLAdmin. You need to inherit this class and override the methods: login , logout and authenticate .","title":"AuthenticationBackend"},{"location":"api_reference/authentication/#sqladmin.authentication.AuthenticationBackend.authenticate","text":"Implement authenticate logic here. This method will be called for each incoming request to validate the authentication.","title":"authenticate()"},{"location":"api_reference/authentication/#sqladmin.authentication.AuthenticationBackend.login","text":"Implement login logic here. You can access the login form data await request.form() andvalidate the credentials.","title":"login()"},{"location":"api_reference/authentication/#sqladmin.authentication.AuthenticationBackend.logout","text":"Implement logout logic here. This will usually clear the session with request.session.clear() .","title":"logout()"},{"location":"api_reference/base_view/","text":"sqladmin.models.BaseView ( BaseModelView ) Base class for defining admnistrative views for the model. Usage from sqladmin import BaseView , expose class CustomAdmin ( BaseView ): name = \"Custom Page\" icon = \"fa-solid fa-chart-line\" @expose ( \"/custom\" , methods = [ \"GET\" ]) def test_page ( self , request : Request ): return self . templates . TemplateResponse ( \"custom.html\" , context = { \"request\" : request }, ) admin . add_base_view ( CustomAdmin ) identity : ClassVar [ str ] Same as name but it will be used for URL of the endpoints. include_in_schema : ClassVar [ bool ] Control whether this endpoint should be included in the schema. methods : ClassVar [ List [ str ]] List of method names for the endpoint. By default it's set to [\"GET\"] only. name : ClassVar [ str ] Name of the view to be displayed.","title":"BaseView"},{"location":"api_reference/base_view/#sqladmin.models.BaseView","text":"Base class for defining admnistrative views for the model. Usage from sqladmin import BaseView , expose class CustomAdmin ( BaseView ): name = \"Custom Page\" icon = \"fa-solid fa-chart-line\" @expose ( \"/custom\" , methods = [ \"GET\" ]) def test_page ( self , request : Request ): return self . templates . TemplateResponse ( \"custom.html\" , context = { \"request\" : request }, ) admin . add_base_view ( CustomAdmin )","title":"BaseView"},{"location":"api_reference/base_view/#sqladmin.models.BaseView.identity","text":"Same as name but it will be used for URL of the endpoints.","title":"identity"},{"location":"api_reference/base_view/#sqladmin.models.BaseView.include_in_schema","text":"Control whether this endpoint should be included in the schema.","title":"include_in_schema"},{"location":"api_reference/base_view/#sqladmin.models.BaseView.methods","text":"List of method names for the endpoint. By default it's set to [\"GET\"] only.","title":"methods"},{"location":"api_reference/base_view/#sqladmin.models.BaseView.name","text":"Name of the view to be displayed.","title":"name"},{"location":"api_reference/model_view/","text":"sqladmin.models.ModelView ( BaseView ) Base class for defining admnistrative behaviour for the model. Usage from sqladmin import ModelView from mymodels import User # SQLAlchemy model class UserAdmin ( ModelView , model = User ): can_create = True can_create : ClassVar [ bool ] Permission for creating new Models. Default value is set to True . can_delete : ClassVar [ bool ] Permission for deleting Models. Default value is set to True . can_edit : ClassVar [ bool ] Permission for editing Models. Default value is set to True . can_export : ClassVar [ bool ] Permission for exporting lists of Models. Default value is set to True . can_view_details : ClassVar [ bool ] Permission for viewing full details of Models. Default value is set to True . column_default_sort : ClassVar [ Union [ str , Tuple [ str , bool ], list ]] Default sort column if no sorting is applied. Example class UserAdmin ( ModelView , model = User ): column_default_sort = \"email\" You can use tuple to control ascending descending order. In following example, items will be sorted in descending order: Example class UserAdmin ( ModelView , model = User ): column_default_sort = ( \"email\" , True ) If you want to sort by more than one column, you can pass a list of tuples Example class UserAdmin ( ModelView , model = User ): column_default_sort = [( \"email\" , True ), ( \"name\" , False )] column_details_exclude_list : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to exclude from displaying in Detail page. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_details_exclude_list = [ User . mail ] column_details_list : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to display in Detail page. Columns can either be string names or SQLAlchemy columns. Note By default all columns of Model are displayed. Example class UserAdmin ( ModelView , model = User ): column_details_list = [ User . id , User . name , User . mail ] column_exclude_list : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to exclude in List page. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_exclude_list = [ User . id , User . name ] column_export_exclude_list : ClassVar [ List [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to exclude when exporting. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_export_exclude_list = [ User . id , User . name ] column_export_list : ClassVar [ List [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to include when exporting. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_export_list = [ User . id , User . name ] column_formatters : ClassVar [ Dict [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ], Callable [[ type , sqlalchemy . sql . schema . Column ], Any ]]] Dictionary of list view column formatters. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_formatters = { User . name : lambda m , a : m . name [: 10 ]} The format function has the prototype: Formatter def formatter ( model , attribute ): # `model` is model instance # `attribute` is a Union[ColumnProperty, RelationshipProperty] pass column_formatters_detail : ClassVar [ Dict [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ], Callable [[ type , sqlalchemy . sql . schema . Column ], Any ]]] Dictionary of details view column formatters. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_formatters_detail = { User . name : lambda m , a : m . name [: 10 ]} The format function has the prototype: Formatter def formatter ( model , attribute ): # `model` is model instance # `attribute` is a Union[ColumnProperty, RelationshipProperty] pass column_labels : ClassVar [ Dict [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ], str ]] A mapping of column labels, used to map column names to new names. Dictionary keys can be string names or SQLAlchemy columns with string values. Example class UserAdmin ( ModelView , model = User ): column_labels = { User . mail : \"Email\" } column_list : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to display in List page. Columns can either be string names or SQLAlchemy columns. Note By default only Model primary key is displayed. Example class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ] column_searchable_list : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] A collection of the searchable columns. It is assumed that only text-only fields are searchable, but it is up to the model implementation to decide. Example class UserAdmin ( ModelView , model = User ): column_searchable_list = [ User . name ] column_sortable_list : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] Collection of the sortable columns for the list view. Example class UserAdmin ( ModelView , model = User ): column_sortable_list = [ User . name ] column_type_formatters : ClassVar [ Dict [ Type , Callable ]] Dictionary of value type formatters to be used in the list view. By default, two types are formatted: - None will be displayed as an empty string - bool will be displayed as a checkmark if it is True otherwise as an X. If you don\u2019t like the default behavior and don\u2019t want any type formatters applied, just override this property with an empty dictionary: Example class UserAdmin ( ModelView , model = User ): column_type_formatters = dict () count_query : ClassVar [ sqlalchemy . sql . selectable . Select ] The SQLAlchemy select expression used for the count query which can be customized. By default it will select all objects without any filters. Example from sqlalchemy import select class UserAdmin ( ModelView , model = User ): count_query = select ( func . count ( User . id )) create_template : ClassVar [ str ] Create view template. Default is create.html . details_template : ClassVar [ str ] Details view template. Default is details.html . edit_template : ClassVar [ str ] Edit view template. Default is edit.html . export_max_rows : ClassVar [ int ] Maximum number of rows allowed for export. Unlimited by default. export_types : ClassVar [ List [ str ]] A list of available export filetypes. Currently only csv is supported. form : ClassVar [ Optional [ Type [ wtforms . form . Form ]]] Form class. Override if you want to use custom form for your model. Will completely disable form scaffolding functionality. Example class MyForm ( Form ): name = StringField ( 'Name' ) class MyModelView ( ModelView , model = User ): form = MyForm form_ajax_refs : ClassVar [ Dict [ str , dict ]] Use Ajax for foreign key model loading. Should contain dictionary, where key is field name and value is a dictionary which configures Ajax lookups. Example class UserAdmin ( ModelAdmin , model = User ): form_ajax_refs = { 'address' : { 'fields' : ( 'street' , 'zip_code' ), 'order_by' : ( 'id' ,), } } form_args : ClassVar [ Dict [ str , Dict [ str , Any ]]] Dictionary of form field arguments. Refer to WTForms documentation for list of possible options. Example from wtforms.validators import DataRequired class MyModelView ( ModelView , model = User ): form_args = dict ( name = dict ( label = \"User Name\" , validators = [ DataRequired ()]) ) form_columns : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to include in the form. Columns can either be string names or SQLAlchemy columns. Note By default all columns of Model are included in the form. Example class UserAdmin ( ModelView , model = User ): form_columns = [ User . name , User . mail ] form_excluded_columns : ClassVar [ Sequence [ Union [ str , sqlalchemy . orm . attributes . InstrumentedAttribute ]]] List of columns to exclude from the form. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): form_excluded_columns = [ User . id ] form_include_pk : ClassVar [ bool ] Control if form should include primary key columns or not. Example class UserAdmin ( ModelView , model = User ): form_include_pk = True form_overrides : ClassVar [ Dict [ str , Type [ wtforms . fields . core . Field ]]] Dictionary of form column overrides. Example class UserAdmin ( ModelView , model = User ): form_overrides = dict ( name = wtf . FileField ) form_widget_args : ClassVar [ Dict [ str , Dict [ str , Any ]]] Dictionary of form widget rendering arguments. Use this to customize how widget is rendered without using custom template. Example class UserAdmin ( ModelView , model = User ): form_widget_args = { \"email\" : { \"readonly\" : True , }, } list_query : ClassVar [ sqlalchemy . sql . selectable . Select ] The SQLAlchemy select expression used for the list page which can be customized. By default it will select all objects without any filters. Example from sqlalchemy import select class UserAdmin ( ModelView , model = User ): list_query = select ( User ) . filter ( User . active == True ) list_template : ClassVar [ str ] List view template. Default is list.html . name_plural : ClassVar [ str ] Plural name of ModelView. Default value is Model class name + s . page_size : ClassVar [ int ] Default number of items to display in List page pagination. Default value is set to 10 . Example class UserAdmin ( ModelView , model = User ): page_size = 25 page_size_options : ClassVar [ Sequence [ int ]] Pagination choices displayed in List page. Default value is set to [10, 25, 50, 100] . Example class UserAdmin ( ModelView , model = User ): page_size_options = [ 50 , 100 ] save_as : ClassVar [ bool ] Set save_as to enable a \u201csave as new\u201d feature on admin change forms. Normally, objects have three save options: \u201cSave\u201d, \u201cSave and continue editing\u201d, and \u201cSave and add another\u201d. If save_as is True, \u201cSave and add another\u201d will be replaced by a \u201cSave as new\u201d button that creates a new object (with a new ID) rather than updating the existing object. By default, save_as is set to False . save_as_continue : ClassVar [ bool ] When save_as=True , the default redirect after saving the new object is to the edit view for that object. If you set save_as_continue=False , the redirect will be to the list view. By default, save_as_continue is set to True . after_model_change ( self , data , model , is_created ) async Perform some actions after a model was created or updated and committed to the database. By default does nothing. after_model_delete ( self , model ) async Perform some actions before a model is deleted. By default do nothing. on_model_change ( self , data , model , is_created ) async Perform some actions before a model is created or updated. By default does nothing. on_model_delete ( self , model ) async Perform some actions before a model is created or updated. By default does nothing. search_placeholder ( self ) Return search placeholder text. Example class UserAdmin ( ModelView , model = User ): column_labels = dict ( name = \"Name\" , email = \"Email\" ) column_searchable_list = [ User . name , User . email ] # placeholder is: \"Name, Email\" search_query ( self , stmt , term ) Specify the search query given the SQLAlchemy statement and term to search for. It can be used for doing more complex queries like JSON objects. For example: return stmt . filter ( MyModel . name == term )","title":"ModelView"},{"location":"api_reference/model_view/#sqladmin.models.ModelView","text":"Base class for defining admnistrative behaviour for the model. Usage from sqladmin import ModelView from mymodels import User # SQLAlchemy model class UserAdmin ( ModelView , model = User ): can_create = True","title":"ModelView"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.can_create","text":"Permission for creating new Models. Default value is set to True .","title":"can_create"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.can_delete","text":"Permission for deleting Models. Default value is set to True .","title":"can_delete"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.can_edit","text":"Permission for editing Models. Default value is set to True .","title":"can_edit"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.can_export","text":"Permission for exporting lists of Models. Default value is set to True .","title":"can_export"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.can_view_details","text":"Permission for viewing full details of Models. Default value is set to True .","title":"can_view_details"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_default_sort","text":"Default sort column if no sorting is applied. Example class UserAdmin ( ModelView , model = User ): column_default_sort = \"email\" You can use tuple to control ascending descending order. In following example, items will be sorted in descending order: Example class UserAdmin ( ModelView , model = User ): column_default_sort = ( \"email\" , True ) If you want to sort by more than one column, you can pass a list of tuples Example class UserAdmin ( ModelView , model = User ): column_default_sort = [( \"email\" , True ), ( \"name\" , False )]","title":"column_default_sort"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_details_exclude_list","text":"List of columns to exclude from displaying in Detail page. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_details_exclude_list = [ User . mail ]","title":"column_details_exclude_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_details_list","text":"List of columns to display in Detail page. Columns can either be string names or SQLAlchemy columns. Note By default all columns of Model are displayed. Example class UserAdmin ( ModelView , model = User ): column_details_list = [ User . id , User . name , User . mail ]","title":"column_details_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_exclude_list","text":"List of columns to exclude in List page. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_exclude_list = [ User . id , User . name ]","title":"column_exclude_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_export_exclude_list","text":"List of columns to exclude when exporting. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_export_exclude_list = [ User . id , User . name ]","title":"column_export_exclude_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_export_list","text":"List of columns to include when exporting. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_export_list = [ User . id , User . name ]","title":"column_export_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_formatters","text":"Dictionary of list view column formatters. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_formatters = { User . name : lambda m , a : m . name [: 10 ]} The format function has the prototype: Formatter def formatter ( model , attribute ): # `model` is model instance # `attribute` is a Union[ColumnProperty, RelationshipProperty] pass","title":"column_formatters"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_formatters_detail","text":"Dictionary of details view column formatters. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): column_formatters_detail = { User . name : lambda m , a : m . name [: 10 ]} The format function has the prototype: Formatter def formatter ( model , attribute ): # `model` is model instance # `attribute` is a Union[ColumnProperty, RelationshipProperty] pass","title":"column_formatters_detail"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_labels","text":"A mapping of column labels, used to map column names to new names. Dictionary keys can be string names or SQLAlchemy columns with string values. Example class UserAdmin ( ModelView , model = User ): column_labels = { User . mail : \"Email\" }","title":"column_labels"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_list","text":"List of columns to display in List page. Columns can either be string names or SQLAlchemy columns. Note By default only Model primary key is displayed. Example class UserAdmin ( ModelView , model = User ): column_list = [ User . id , User . name ]","title":"column_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_searchable_list","text":"A collection of the searchable columns. It is assumed that only text-only fields are searchable, but it is up to the model implementation to decide. Example class UserAdmin ( ModelView , model = User ): column_searchable_list = [ User . name ]","title":"column_searchable_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_sortable_list","text":"Collection of the sortable columns for the list view. Example class UserAdmin ( ModelView , model = User ): column_sortable_list = [ User . name ]","title":"column_sortable_list"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.column_type_formatters","text":"Dictionary of value type formatters to be used in the list view. By default, two types are formatted: - None will be displayed as an empty string - bool will be displayed as a checkmark if it is True otherwise as an X. If you don\u2019t like the default behavior and don\u2019t want any type formatters applied, just override this property with an empty dictionary: Example class UserAdmin ( ModelView , model = User ): column_type_formatters = dict ()","title":"column_type_formatters"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.count_query","text":"The SQLAlchemy select expression used for the count query which can be customized. By default it will select all objects without any filters. Example from sqlalchemy import select class UserAdmin ( ModelView , model = User ): count_query = select ( func . count ( User . id ))","title":"count_query"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.create_template","text":"Create view template. Default is create.html .","title":"create_template"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.details_template","text":"Details view template. Default is details.html .","title":"details_template"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.edit_template","text":"Edit view template. Default is edit.html .","title":"edit_template"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.export_max_rows","text":"Maximum number of rows allowed for export. Unlimited by default.","title":"export_max_rows"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.export_types","text":"A list of available export filetypes. Currently only csv is supported.","title":"export_types"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form","text":"Form class. Override if you want to use custom form for your model. Will completely disable form scaffolding functionality. Example class MyForm ( Form ): name = StringField ( 'Name' ) class MyModelView ( ModelView , model = User ): form = MyForm","title":"form"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_ajax_refs","text":"Use Ajax for foreign key model loading. Should contain dictionary, where key is field name and value is a dictionary which configures Ajax lookups. Example class UserAdmin ( ModelAdmin , model = User ): form_ajax_refs = { 'address' : { 'fields' : ( 'street' , 'zip_code' ), 'order_by' : ( 'id' ,), } }","title":"form_ajax_refs"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_args","text":"Dictionary of form field arguments. Refer to WTForms documentation for list of possible options. Example from wtforms.validators import DataRequired class MyModelView ( ModelView , model = User ): form_args = dict ( name = dict ( label = \"User Name\" , validators = [ DataRequired ()]) )","title":"form_args"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_columns","text":"List of columns to include in the form. Columns can either be string names or SQLAlchemy columns. Note By default all columns of Model are included in the form. Example class UserAdmin ( ModelView , model = User ): form_columns = [ User . name , User . mail ]","title":"form_columns"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_excluded_columns","text":"List of columns to exclude from the form. Columns can either be string names or SQLAlchemy columns. Example class UserAdmin ( ModelView , model = User ): form_excluded_columns = [ User . id ]","title":"form_excluded_columns"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_include_pk","text":"Control if form should include primary key columns or not. Example class UserAdmin ( ModelView , model = User ): form_include_pk = True","title":"form_include_pk"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_overrides","text":"Dictionary of form column overrides. Example class UserAdmin ( ModelView , model = User ): form_overrides = dict ( name = wtf . FileField )","title":"form_overrides"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.form_widget_args","text":"Dictionary of form widget rendering arguments. Use this to customize how widget is rendered without using custom template. Example class UserAdmin ( ModelView , model = User ): form_widget_args = { \"email\" : { \"readonly\" : True , }, }","title":"form_widget_args"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.list_query","text":"The SQLAlchemy select expression used for the list page which can be customized. By default it will select all objects without any filters. Example from sqlalchemy import select class UserAdmin ( ModelView , model = User ): list_query = select ( User ) . filter ( User . active == True )","title":"list_query"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.list_template","text":"List view template. Default is list.html .","title":"list_template"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.name_plural","text":"Plural name of ModelView. Default value is Model class name + s .","title":"name_plural"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.page_size","text":"Default number of items to display in List page pagination. Default value is set to 10 . Example class UserAdmin ( ModelView , model = User ): page_size = 25","title":"page_size"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.page_size_options","text":"Pagination choices displayed in List page. Default value is set to [10, 25, 50, 100] . Example class UserAdmin ( ModelView , model = User ): page_size_options = [ 50 , 100 ]","title":"page_size_options"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.save_as","text":"Set save_as to enable a \u201csave as new\u201d feature on admin change forms. Normally, objects have three save options: \u201cSave\u201d, \u201cSave and continue editing\u201d, and \u201cSave and add another\u201d. If save_as is True, \u201cSave and add another\u201d will be replaced by a \u201cSave as new\u201d button that creates a new object (with a new ID) rather than updating the existing object. By default, save_as is set to False .","title":"save_as"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.save_as_continue","text":"When save_as=True , the default redirect after saving the new object is to the edit view for that object. If you set save_as_continue=False , the redirect will be to the list view. By default, save_as_continue is set to True .","title":"save_as_continue"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.after_model_change","text":"Perform some actions after a model was created or updated and committed to the database. By default does nothing.","title":"after_model_change()"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.after_model_delete","text":"Perform some actions before a model is deleted. By default do nothing.","title":"after_model_delete()"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.on_model_change","text":"Perform some actions before a model is created or updated. By default does nothing.","title":"on_model_change()"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.on_model_delete","text":"Perform some actions before a model is created or updated. By default does nothing.","title":"on_model_delete()"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.search_placeholder","text":"Return search placeholder text. Example class UserAdmin ( ModelView , model = User ): column_labels = dict ( name = \"Name\" , email = \"Email\" ) column_searchable_list = [ User . name , User . email ] # placeholder is: \"Name, Email\"","title":"search_placeholder()"},{"location":"api_reference/model_view/#sqladmin.models.ModelView.search_query","text":"Specify the search query given the SQLAlchemy statement and term to search for. It can be used for doing more complex queries like JSON objects. For example: return stmt . filter ( MyModel . name == term )","title":"search_query()"}]}